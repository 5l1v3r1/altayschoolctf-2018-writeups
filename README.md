# Kenobium

### PPC/Web

На старте имеем ссылку на сайт, который запрашивает от нас некий kenobium браузер. Путем несложных умозаключений, приходим к выводу, что его не существует и нам придется перехитрить сервер.

Сделать это оказывается не сложно, достаточно просто вставить *kenobium* в заголовок *user-agent* и сервер жизнерадостно пускает нас на свою территорию.

Однако, на этом песня не заканчивается, теперь нас ждет весьма странная *капча* с вопросом и текстами-подсказками, которая проверяет наличие у нас аналитического мышления ... Много-много раз.

Теперь у нас два пути:

 - Писать скрипт для автоматизации выполнения капчи
 - ( *Для извращенцев* ) Проходить все вручную

Выбираем первый вариант. Скрипт должен *парсить* страницу, проверять *ключевое слово* в вопросе ( выделено КАПСОМ ), находить его в вариантах *помощи* и сдавать как ответ *заголовок* нужного варианта из помощи, не забывая при этом подменять *user-agent*

Пример скрипта для решения (php) :
```
<?php
$url="адрес_сервера";
$ch = curl_init( $url );

curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);   
curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); 
curl_setopt($ch, CURLOPT_ENCODING, "");   
curl_setopt($ch, CURLOPT_USERAGENT, "kenobium");  // useragent
curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 120); 
curl_setopt($ch, CURLOPT_TIMEOUT, 120);  
curl_setopt($ch, CURLOPT_COOKIEJAR, __DIR__ . "/cookie.txt");
curl_setopt($ch, CURLOPT_COOKIEFILE, __DIR__ . "/cookie.txt");


$html = curl_exec($ch);

echo $html;

for($i=0;$i<101;$i++)
{
    $quest=stristr($html,"<p name=\"expression\">");

    preg_match("~<p name=\"expression\">(.*?)<\/p>~",$quest,$needle);
    preg_match("~[A-Z]+\s~",$needle[1],$needle);

    $needle=trim($needle[0]);

    $helps=strstr($html,"<p name=\"title\">");
    $one=$helps;
    preg_match("~<p name=\"title\">.*?<\/p>.*?(<p>(.*?)<\/p>?)~s",$one,$one);
    preg_match("~<p name=\"title\"><strong>(.*?)<\/strong><\/p>~",$helps,$onetit);
    $one=$one[0];
    $onetit=$onetit[1];
    $helps=substr($html,strlen($one));

    $too=$helps;
    preg_match("~<p name=\"title\">.*?<\/p>.*?(<p>(.*?)<\/p>?)~s",$too,$too);
    preg_match("~<p name=\"title\"><strong>(.*?)<\/strong><\/p>~",$helps,$tootit);
    $too=$too[0];
    $tootit=$tootit[1];
    $helps=substr($helps,strlen($too));

    $thr=$helps;
    preg_match("~<p name=\"title\">.*?<\/p>.*?(<p>(.*?)<\/p>?)~s",$thr,$thr);
    preg_match("~<p name=\"title\"><strong>(.*?)<\/strong><\/p>~",$helps,$thrtit);
    $thr=$thr[0];
    $thrtit=$thrtit[1];
    $helps=substr($helps,strlen($thr));


    if(strpos($one,$needle)!==false)
    {
        $solve=$onetit;
    }
    else if(strpos($too,$needle)!==false)
    {
        $solve=$tootit;
    }
    else if(strpos($thr,$needle)!==false)
    {
        $solve=$thrtit;
    }


    curl_setopt($ch, CURLOPT_POST, 1);
    curl_setopt($ch, CURLOPT_POSTFIELDS, "user_text=$solve");
    $html = curl_exec($ch);
    
    echo $html;
}


curl_close($ch);
```
 Выполняем, на 100 проходе получаем флаг. Вы великолепны.
 
 И да пребудет с вами Сила!
 
```School{kenobium_browser_is_good}```
 
 ---

# Head die

### Web

На старте имеем ссылку на сайт, который представляет из себя просто набор красивых картинок с неработающими кнопками лайк\дизлайк ( социальные сети? фиии ).

Первым делом лезем в *код страницы* и обнаруживаем там скрытый пункт меню *flag.php*. Но при попытке зайти туда, нам выдается страница *noflag.php* и сообщение, что страницы не существует.

Однако, это явно не стандартная обработка ошибки 404. По *запросам* в браузере можно отследить, что со страницы *flag.php* происходит постоянный *редирект* на уже известную *noflag.php*.

Значит, наша задача не дать сделать этот *редирект*. Тут нам поможет:

 - Самописный скрипт в 5 строчек
 - Онлайн-сервисы для выполнения curl-запросов

Пример скрипта для решения (php) ( О да, самый лаконичный скрипт на диком западе ) :
```
<?php
$url = "адрес_сервера";

$ch = curl_init();
curl_setopt($ch, CURLOPT_URL,$url);
$result=curl_exec ($ch);
```
 Выполняем, *редирект* не происходит и на страницу выводится флаг, потому что в ~~гавно~~коде не стоит функция die() и страница продолжает выполенение. Итого, на странице получаем флаг. Вы великолепны.

UPD: Ох сколько же людей полегло на этом таске. Пожалуйста, не выходите с вилами на автора;)
 
 И да пребудет с вами Сила!
 
```School{use_die_after_redirect}```
 
 ---

# Crazzzya

### Crypto

На старте имеем странный файл, который **ОБЯЗАТЕЛЬНО** нужно скачать(иначе в нем отображаются иероглифы, многие из-за этого шли по ложному пути).
В нем оказываются комбинации ЫыыЫыЫы.
Путем не сложных умозаключений, доходим, что это можно рассматривать как *бинарный код*: 

 - Ы - 1
 - ы - 0
 
 Делаем замену, затем заходим на любой сервис с функцией *bin to text* и жизнерадостно сдаем флаг.
 
 И да пребудет с вами Сила!
 
```School{it's_a_sahelantrop}```
 
 ---

# byte-by-byte

### PPC

На старте имеем файл, в котором лежит пачка хэшей md5 и ... больше ничего.
Соответственно, в первую очередь пробуем проверить хэши по *радужным таблицам* или просто *сбрутить*.

При правильном выполнении предыдущих пунктов, обнаруживаем хэши от 1 и от 3 символов. Первые образуют не что иное, как флаг, а остальные - лишь мусор.

Пример скрипта для решения (php) :
```
<?php

$in=fopen("inp.txt","r+");
$out=fopen("out.txt","a+");
$alph="qwertyuiopasdfghjklzxcvbnmQWERTYUIOPSDFGHJKLZXCVBNM1234567890{}_";

while(($buff=fgets($in))!==false)
{
    $buff=trim($buff);
    for($i=0;$i<strlen($alph);$i++)
    {
        if(md5($alph[$i])==$buff)
        {
            fwrite($out,$alph[$i]);
            continue;
        }
    }
}
```
 Выполняем, получаем флаг. Вы великолепны.
 
 И да пребудет с вами Сила!
 
```School{this_is_brut_mother_father}```
 
 ---

# 404 quest not found

### Web

Таск представляет из себя простейшую ssti в чистом виде. 

![](https://bitbucket.org/Likc/writeups/downloads/Screenshot_2017-11-01-00-15-42.png)

Как мы видим страница 404 динамическая, т.е. формируется в зависимости от url. Сразу же можно найти xss, но это не так интересно.

Первым делом стоит посмотреть конфигурацию сайта.

> /{{ config.items() }}

Что вернет нам все пары из словаря конфигов

![](https://bitbucket.org/Likc/writeups/downloads/IMG_20171101_003150.jpg)

На этом таск решен.

# Config viewer

### Web

Сервис давал возможность просматривать конфиги php, mysql и apache, а также еще какой-то config.yml. 
![enter image description here](https://preview.ibb.co/c07Fzx/image.png)
Все ответы возвращались в json-сериализованном виде. Как можно было заметить, все урлы были однотипны, кроме последнего:

 - /api/v1/config/php
 - /api/v1/config/mysql
 - /api/v1/config/apache
 - **/api/v1/config/custom?file=config.yml**
 
Последняя ссылка подсказывает, что у нас здесь возможно **Local File Inclusion**, т.к. подключается на чтение файл config.yml. В html-комментарии также можно было заметить **"Created by username"**, что намекало на имя linux-юзера. 
Вспоминаем, что в линухе можно почитать историю последних выполненных команд через файл **.bash_history**. Пробуем его заинклудить:
 - **/api/v1/config/custom?file=username/.bash_history.**
В истории видим где был создан файл с флагом. Путь до флага вышел следующий:
 - **/opt/F_L_A_G**
Инклудим данный файл и получаем флаг.

---

# R&J

### stego

Некоторые буквы ‘а’ и ‘о’ - русские. Найти все, заменить о на 0 и а на 1, получить флаг в двоичном виде, перевести в ascii


---


# Stirlitz

### ppc


Бот пишет по одной букве в двоичном виде и сразу заменяет на другую фразу. Нужно автоматизировать получение новых сообщений Telegram, чтобы успеть.


# WTF 

###  stego

Дано 8 одинаковых, пронумерованных картинок. Исследуем картинки и замечаем, что в тегах что-то есть. По отдельному тегу ничего не понятно. Но т.к. картинки пронумерованы, объединяем теги в одну строку. В итоге видим, что в конце стоит "=" это сразу же наводит на мысль о base. Пробуем расшифровать строку в base64 и получаем новую строку, значит мы на правильном направлении. Повторяем расшифровку до появления флага.
=)

---

# seeker

### stego

Дана картинка с изображением, похожим на значок winrar. Что же это может быть? (Переименовываем файл в rar и) открываем  в winrar (либо другом архиваторе).
Видим папки, файлы, в их числе картинка с названием flag. Открываем, и радуемся тому, что это ещё не конец. На картинке говориться, что флаг в документе, а не в архиве. Так же там изображен малозаметный значок Microsoft Word.  Дальше два варианта
1) (Зная, что doc docx документы Word представляют собой архив) понимаем, что все кроме flag.png в архиве походит на внутренности doc(x) документа. Переименовываем изначальный файл (seeker) в .docx  и открываем в Word. И вот, после двух предупреждений, перед вами появляется флаг.
2) Посмотрев картинку, вы начинаете рыскать по архиву в поисках флага. Помня ту подсказку про документ, в папке Word вы открываете document.xml и каким либо образом находите среди данных флаг.

---

# Very long password

### ppc

1.Пишем программу:

```password="5"
  i="5"
  while(len(password) != 9322): 
    i= int(i) + 5 
    password = password + str(i) 
  print(password)
```

2.Подаем на вход пароль любому генратору хешей SHARK-32 
3.Получаем флаг

Easy!

---

# Very long alghorytm

### crypto

1.Свиток античных времен, значит алгоритм шифрования существовал давно. Цезарь не вариант, у него ключ только из одной неизвестной переменной, а тут целых две. Остается только Аффинный шифр. 
2.Подбираем число обратное А, в итоге оно у нас равняется 17. 
3.Наличие фигурной скобоки в конце криптограммы говорит, что алфавит у нас не 26 сиволов, а больше. Попробуем взять мощность m в 28 символов(+ к алфавиту добавились еще  фигурные скобоки), нумерация начинается с нуля, как просит алгоритм. 
4.По формуле D(y)=a^-1(y+m-b) mod m находим исходное сообщение, т.е флаг.

---

# It's all about the game

### crypto

По контексту задания понятно, что шифр как-то связан с игрой крестики-нолики. Для расшифровки сообщения нам необходимо начертить стандартное поле для этой игры, затем в каждую клетку мы должны внести по три английских буквы в алфавитном порядке, в последней клетке третий символ является пробелом.

Это должно выглядеть следующим образом:
![](https://cdn.segmentnext.com/wp-content/uploads/2013/07/cipherpigpen-1.jpg)

Каждый из знаков шифра представляет собой одну из клеток поля (нарисована черным цветом), где красная линия занимает одну из трех позиций, соответствующих определенной букве алфавита. То есть, по положению клетки и линии мы определяем, какая буква зашифрована. Таким образом мы должны расшифровать все сообщение.

---

# 25 shades of blue

### stego

Дан файл без расширения. Понимаем, что это xcf (формат GIMP'а).  Каждый слой имеет отдельный цвет, и чтобы решить нужно их расставить в порядке номеров в названии слоев. Далее два вариант решения: либо пипеткой брать цвета и полученный hex переводить в символ, либо открыть файл блокнотом и увидеть повторяющиеся буквы флага.

---

# Seriously?

### crypto

Рисуем по-координатам, в качестве поля - панель набора номера на телефоне

---

# Knock-knock

### misc

Фильтруем дамп по icmpv6. Хинтом является пингуемое имя хоста. Далее видим закономерность в ttl. 10 = 0, 11=1. Переписываем бинарку и конвертим в текст.

---

# figures on the field

### misc

Base64 to file -> Arthur Minimoys Alphabet -> Numbers in words -> Hex -> Flag
